
#include "so_long.h"







// int	check_if_all(void)
// {
// 	if(g_struct.collected == g_struct.all_collectibles)
// 	{
// 		int x;
// 		int y;

// 		x = g_struct.g_exit_img->instances->x;
// 		y = g_struct.g_exit_img->instances->y;
// 		g_struct.g_exit_img = mlx_texture_to_image(g_struct.mlx,
// 			g_struct.open_exit_texture);
// 		mlx_image_to_window(g_struct.mlx, g_struct.floor, x, y);
// 		mlx_image_to_window(g_struct.mlx, g_struct.g_exit_img, x, y);
// 		return(1);
// 	}
// 	return(0);
// }

// int	hit_an_exit(int x, int y)
// {
// 	if (g_struct.hero.x/32 == x/32 
// 		&& g_struct.hero.y/32 == y/32
// 		&& g_struct.exit_open == 1)
// 		return (1);
// 	return (0);
// }

// int	is_at_exit(int x, int y)
// {
// 	if (g_struct.hero.x/32 == x/32 
// 		&& g_struct.hero.y/32 == y/32)
// 		return (1);
// 	return (0);
// }

// void	ft_go_up(mlx_key_data_t keydata, void *param)
// {
// 	param = (void*)param;
// 	if (keydata.action == MLX_RELEASE)
// 	{
// 		if(g_struct.map[g_struct.hero.y/32-1][g_struct.hero.x/32] != '1')
// 		{	
// 			mlx_image_to_window(g_struct.mlx, g_struct.floor, g_struct.hero.x, g_struct.hero.y);
// 			if(is_at_exit(g_struct.g_exit_img->instances->x, g_struct.g_exit_img->instances->y))
// 				mlx_image_to_window(g_struct.mlx, g_struct.g_exit_img, g_struct.hero.x, g_struct.hero.y);
			
// 			g_struct.hero.y -= 32;
// 			if(g_struct.map[g_struct.hero.y/32][g_struct.hero.x/32] == 'C')
// 			{
// 				g_struct.collected++;
// 				if(check_if_all())
// 					g_struct.exit_open = 1;
// 			}
// 			mlx_image_to_window(g_struct.mlx, g_struct.hero.hero, g_struct.hero.x, g_struct.hero.y);
// 			ft_printf("Actions taken:%d\n",++g_struct.action_counter);
// 		}
// 	}
// }

// void	ft_go_down(mlx_key_data_t keydata, void *param)
// {
// 	param = (void*)param;
// 	if (keydata.action == MLX_RELEASE)
// 	{
// 		if(g_struct.map[g_struct.hero.y/32+1][g_struct.hero.x/32] != '1')
// 		{	
// 			mlx_image_to_window(g_struct.mlx, g_struct.floor, g_struct.hero.x, g_struct.hero.y);
// 			if(is_at_exit(g_struct.g_exit_img->instances->x, g_struct.g_exit_img->instances->y))
// 				mlx_image_to_window(g_struct.mlx, g_struct.g_exit_img, g_struct.hero.x, g_struct.hero.y);
// 			g_struct.hero.y += 32;
// 			if(g_struct.map[g_struct.hero.y/32][g_struct.hero.x/32] == 'C')
// 			{
// 				g_struct.collected++;
// 				if(check_if_all())
// 					g_struct.exit_open = 1;
// 			}
// 			mlx_image_to_window(g_struct.mlx, g_struct.hero.hero, g_struct.hero.x, g_struct.hero.y);
// 			ft_printf("Actions taken:%d\n",++g_struct.action_counter);
// 		}
// 	}
// }

// void	ft_go_left(mlx_key_data_t keydata, void *param)
// {
// 	param = (void*)param;
// 	if (keydata.action == MLX_RELEASE)
// 	{
// 		if(g_struct.map[g_struct.hero.y/32][g_struct.hero.x/32-1] != '1')
// 		{	
// 			mlx_image_to_window(g_struct.mlx, g_struct.floor, g_struct.hero.x, g_struct.hero.y);
// 			if(is_at_exit(g_struct.g_exit_img->instances->x, g_struct.g_exit_img->instances->y))
// 				mlx_image_to_window(g_struct.mlx, g_struct.g_exit_img, g_struct.hero.x, g_struct.hero.y);
// 			g_struct.hero.x -= 32;
// 			if(g_struct.map[g_struct.hero.y/32][g_struct.hero.x/32] == 'C')
// 			{
				
// 				g_struct.collected++;
// 				if(check_if_all())
// 					g_struct.exit_open = 1;
// 			}
// 			mlx_image_to_window(g_struct.mlx, g_struct.hero.hero, g_struct.hero.x, g_struct.hero.y);
// 			ft_printf("Actions taken:%d\n",++g_struct.action_counter);
// 		}
// 	}
// }

// void	ft_go_right(mlx_key_data_t keydata, void *param)
// {
// 	param = (void*)param;
// 	if (keydata.action == MLX_RELEASE)
// 	{
// 		if(g_struct.map[g_struct.hero.y/32][g_struct.hero.x/32+1] != '1')
// 		{	
// 			mlx_image_to_window(g_struct.mlx, g_struct.floor, g_struct.hero.x, g_struct.hero.y);
// 			if(is_at_exit(g_struct.g_exit_img->instances->x, g_struct.g_exit_img->instances->y))
// 				mlx_image_to_window(g_struct.mlx, g_struct.g_exit_img, g_struct.hero.x, g_struct.hero.y);
			
// 			g_struct.hero.x += 32;
// 			if(g_struct.map[g_struct.hero.y/32][g_struct.hero.x/32] == 'C')
// 			{
// 				g_struct.collected++;
// 				if(check_if_all())
// 					g_struct.exit_open = 1;
// 			}
// 			mlx_image_to_window(g_struct.mlx, g_struct.hero.hero, g_struct.hero.x, g_struct.hero.y);
// 			ft_printf("Actions taken:%d\n",++g_struct.action_counter);
// 		}
// 	}
// }

// void	hook(void *param)
// {
// 	mlx_t	*mlx;

// 	mlx = param;
// 	if (mlx_is_key_down(mlx, MLX_KEY_ESCAPE))
// 		mlx_close_window(mlx);
// 	if ((mlx_is_key_down(mlx, MLX_KEY_UP) || mlx_is_key_down(mlx, MLX_KEY_W)))
// 		mlx_key_hook(g_struct.mlx, ft_go_up, param);
// 	if ((mlx_is_key_down(mlx, MLX_KEY_DOWN) || mlx_is_key_down(mlx, MLX_KEY_S)))
// 		mlx_key_hook(g_struct.mlx, ft_go_down, param);
// 	if ((mlx_is_key_down(mlx, MLX_KEY_LEFT) || mlx_is_key_down(mlx, MLX_KEY_A)))
// 		mlx_key_hook(g_struct.mlx, ft_go_left, param);
// 	if ((mlx_is_key_down(mlx, MLX_KEY_RIGHT) || mlx_is_key_down(mlx, MLX_KEY_D)))
// 		mlx_key_hook(g_struct.mlx, ft_go_right, param);
// 	if (hit_an_exit(g_struct.g_exit_img->instances->x, g_struct.g_exit_img->instances->y))
// 	{
// 		write(1, "GAMEOVER", 8);
// 		mlx_close_window(mlx);
// 	}
// }

// void	ft_render_chars(char *line, int y)
// {
// 	int x;
	
// 	x = 0;
// 	while(*line)
// 	{
// 		if(*line == '1')
// 			mlx_image_to_window(g_struct.mlx, g_struct.crate, x, y);
// 		if(*line == '0')
// 			mlx_image_to_window(g_struct.mlx, g_struct.floor, x, y);
// 		if(*line == 'C')
// 		{
// 			mlx_image_to_window(g_struct.mlx, g_struct.floor, x, y);
// 			mlx_image_to_window(g_struct.mlx, g_struct.collectible, x, y);
// 		}	
// 		if(*line == 'P')
// 		{
// 			mlx_image_to_window(g_struct.mlx, g_struct.floor, x, y);
// 			g_struct.hero.x = x;
// 			g_struct.hero.y = y;
// 		}
// 		if(*line == 'E')
// 		{
// 			mlx_image_to_window(g_struct.mlx, g_struct.floor, x, y);
// 			mlx_image_to_window(g_struct.mlx, g_struct.g_exit_img, x, y);
// 		}	
// 		x += 32;
// 		line++;	
// 	}
// }

// void	ft_render_map(void)
// {
// 	int		y;
// 	int		x;
	
// 	x = 0;
// 	y = 0;
// 	while(g_struct.map[x])
// 	{
// 		if(g_struct.map[x] != NULL)
// 			ft_render_chars(g_struct.map[x], y);	
// 		y += 32;
// 		x++;
// 	}
// 	mlx_image_to_window(g_struct.mlx, g_struct.hero.hero, g_struct.hero.x, g_struct.hero.y);
	
// }

void	ft_create_array(char *path, struct g_structure *g_struct)
{
	int		fd;
	// int		width;
	// int		height;
	char	*line;
	char	**tmp;
	int		j;
	
	tmp = NULL;
	fd = open(path,O_RDONLY);
	line = get_next_line(fd);
	g_struct->width = ft_strlen(line);
	g_struct->height = 0;
	while(line)
	{
		if(g_struct->map)
			tmp = g_struct->map;	
		g_struct->map = malloc(g_struct->height+2);
		if(!g_struct->map)
			ft_printf("Error\n");
		g_struct->map[g_struct->height+1] = NULL;
		g_struct->map[g_struct->height] = line;
		// line = NULL;
		j= 0;
		while(j<g_struct->height)
		{
			g_struct->map[j] = tmp[j];
			j++;
		}
		// ft_printf("map:%s",g_struct.map[j]);	
		// ft_printf("line:%s",line);
		if(tmp)
			free(tmp);
		// free(line);
		line = get_next_line(fd);
		g_struct->height++;
	}
	close(fd);
	// g_struct.map[height] = NULL;
	// ft_printf("width: %d, height: %d\n",g_struct.width,g_struct.height);
	// g_struct.mlx = mlx_init( width * 32, height * 32, "GAMEBOY", true);
	// ft_printf("width: %d, height: %d\n",g_struct.width,g_struct.height);
}
	// width = ft_strlen(line);
	// height = 0;
	// g_struct.map = malloc(sizeof(char*) * width + 1);
	// if(!g_struct.map)
	// 	free(g_struct.map);
	// i = 0;
	// while(line)
	// {
	// 	line_width = ft_strlen(line);
	// 	g_struct.map[i] = malloc(sizeof(char) * line_width);
	// 	if(!g_struct.map[i])
	// 		gn_free_buf(&g_struct.map[i]);
	// 	if(line != NULL)
	// 		g_struct.map[i] = ft_strdup(line);
	// 	// g_struct.map[i][line_width] = '\0';
	// 	line = get_next_line(fd);
	// 	height++;
	// 	i++;		
	// }

void	ft_initialise_graphics(struct g_structure *g_struct)
{
	g_struct->texture = mlx_load_png("/Users/dhendzel/Documents/Pixel_Crawler/Heroes/Knight/Idle/Knight.png");
	g_struct->crate_texture = mlx_load_png("assets/crate.png");
	g_struct->floor_texture = mlx_load_png("assets/floor.png");
	g_struct->exit_texture = mlx_load_png("assets/closed_exit.png");
	g_struct->open_exit_texture = mlx_load_png("assets/open_exit.png");
	g_struct->col_texture = mlx_load_png("assets/coin.png");
	g_struct->crate = mlx_texture_to_image(g_struct->mlx, g_struct->crate_texture);
	g_struct->floor = mlx_texture_to_image(g_struct->mlx, g_struct->floor_texture);
	g_struct->collectible = mlx_texture_to_image(g_struct->mlx, g_struct->col_texture);
	g_struct->hero.hero = mlx_texture_to_image(g_struct->mlx, g_struct->texture);
	g_struct->g_exit_img = mlx_texture_to_image(g_struct->mlx,
			g_struct->exit_texture);
}

int32_t	main(int argc, char **argv)
{
	struct g_structure g_struct;
	if(argc != 2)
	{
		ft_printf("Incorrect input, my dear, try again!\n");
		ft_printf("Correct input is ./game 'relative map path'\n");
		return(EXIT_FAILURE);
	}
	g_struct.action_counter = 0;
	g_struct.exit_open = 0;
	g_struct.all_collectibles = 2;
	g_struct.collected = 0;
	g_struct.mlx = NULL;
	ft_create_array(argv[1],&g_struct);
	ft_printf("1");
	g_struct.mlx = mlx_init(g_struct.width * 32, g_struct.height * 32, "GAMEBOY", true);
	// ft_initialise_graphics(&g_struct);
	// // ft_initialise_map();
	// if (!g_struct.mlx)
	// 	exit(EXIT_FAILURE);
	// ft_render_map();
	// system("leaks game");
	// mlx_loop_hook(g_struct.mlx, &hook, g_struct.mlx);
	mlx_loop(g_struct.mlx);
	mlx_terminate(g_struct.mlx);
	return (EXIT_SUCCESS);
}